# Name of your workflow, displayed in the GitHub Actions UI
name: Deploy Pre-built Docker Image to GCP Cloud Run (Service Account Key) # Name adjusted for clarity

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Docker image tag (e.g., latest, main, or a specific SHA)'
        required: true
        default: 'main'
      service_name:
        description: 'Cloud Run Service Name to deploy to'
        required: true
        default: 'gcpdemo' # <<< IMPORTANT: Default Cloud Run service name

env:
  GCP_PROJECT_ID: 'superb-tendril-454116-i5' # <<< IMPORTANT: Replace with your GCP Project ID
  CLOUD_RUN_REGION: 'us-central1' # <<< IMPORTANT: Choose your Cloud Run region
  # Ensure these match your GitHub Packages image details
  GHCR_REGISTRY: ghcr.io
  GKE_CLUSTER_NAME: spalakolu-cluster1
  GKE_CLUSTER_ZONE: 'us-central1'
  
  GHCR_IMAGE_OWNER: 'sumanpalakolu' # <<< IMPORTANT: Your GitHub username or organization
  GHCR_IMAGE_NAME: 'demo' # <<< IMPORTANT: Must match the image name from your build workflow
  # NEW: Artifact Registry Repository details
  GAR_REGION: 'us-central1' # <<< IMPORTANT: Match your Artifact Registry region
  GAR_REPO_NAME: 'cloud-run-images' # <<< IMPORTANT: The Artifact Registry repo name you created

jobs:
  deploy:
    runs-on: ubuntu-latest

    permissions:
      contents: 'read'
      packages: 'write' # Not needed if you're only pushing to GAR, not GHCR here
      id-token: 'write' # Only needed for Workload Identity Federation

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      # Step 1: Authenticate to Google Cloud (using service account key)
      - id: 'auth'
        name: 'Authenticate to Google Cloud'
        uses: 'google-github-actions/auth@v2'
        with:
          credentials_json: '${{ secrets.GCP_SA_KEY }}' # Or workload_identity_provider for WIF

      # Step 2: Log in to GitHub Container Registry (to pull the image)
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.GHCR_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Step 3: Get the full Docker image path from GHCR
      - name: Get GHCR Image Path
        id: ghcr_image_path
        run: |
          GHCR_FULL_IMAGE="${{ env.GHCR_REGISTRY }}/${{ env.GHCR_IMAGE_OWNER }}/${{ env.GHCR_IMAGE_NAME }}:${{ github.event.inputs.image_tag }}"
          echo "Full GHCR Docker image path: ${GHCR_FULL_IMAGE}"
          echo "image_path=${GHCR_FULL_IMAGE}" >> "$GITHUB_OUTPUT"

      # --- NEW STEPS: Pull from GHCR, push to GAR ---

      # Step 4: Configure Docker to use Google Cloud CLI for Artifact Registry
      - name: Configure Docker to use gcloud as a credential helper
        run: gcloud auth configure-docker ${{ env.GAR_REGION }}-docker.pkg.dev

      # Step 5: Pull the image from GHCR, tag it for GAR, and push to GAR
      - name: Copy Docker Image from GHCR to Artifact Registry
        id: copy_image_to_gar
        run: |
          GHCR_IMAGE="${{ steps.ghcr_image_path.outputs.image_path }}"
          GAR_IMAGE="${{ env.GAR_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.GAR_REPO_NAME }}/${{ env.GHCR_IMAGE_NAME }}:${{ github.event.inputs.image_tag }}"

          echo "Pulling ${GHCR_IMAGE}..."
          docker pull ${GHCR_IMAGE}

          echo "Tagging ${GHCR_IMAGE} as ${GAR_IMAGE}..."
          docker tag ${GHCR_IMAGE} ${GAR_IMAGE}

          echo "Pushing ${GAR_IMAGE} to Artifact Registry..."
          docker push ${GAR_IMAGE}

          echo "gar_image_path=${GAR_IMAGE}" >> "$GITHUB_OUTPUT" # Output for later use
      - name: 'Get GKE Credentials'
        uses: 'google-github-actions/get-gke-credentials@v2'
        with:
          cluster_name: ${{ env.GKE_CLUSTER_NAME }}
          location: ${{ env.GKE_CLUSTER_ZONE }}

      # Step 6: Update the Kubernetes deployment manifest with the new image tag.
      # This ensures you're deploying the exact image that was just pushed.
      - name: 'Update K8s Manifest'
        run: |
          sed -i "s|<YOUR_IMAGE_URI>|${{ steps.copy_image_to_gar.outputs.gar_image_path }}|g" k8s/deployment.yaml

      # Step 7: Apply the Kubernetes manifests to deploy the application.
      - name: 'Deploy to GKE'
        run: |
          kubectl apply -f k8s/deployment.yaml
          kubectl apply -f k8s/service.yaml
          echo "Deployment and Service applied. Check GKE to see the status."

      # Step 8: Optional - Wait for the deployment rollout to complete.
      - name: 'Wait for Deployment Rollout'
        run: |
          kubectl rollout status deployment/${{ env.IMAGE_NAME }} --timeout=5m
